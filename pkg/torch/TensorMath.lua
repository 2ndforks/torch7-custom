local interface = wrap.CInterface.new()
local method = wrap.CInterface.new()

-- special argument specific to torch package
local argtypes = {}
argtypes.LongArg = {

   vararg = true,
   
   helpname = function(arg)
                 return "(LongStorage | dim1 [dim2...])"
              end,
   
   declare = function(arg)
                local txt = {}
                table.insert(txt, string.format("local arg%d = torch.LongStorage()", arg.i))
                table.insert(txt,
[[
local function islongarg(s, idx, arg, narg)
   if type(arg[idx]) == 'torch.LongStorage' then
      s:resizeAs(arg[idx])
      s:copy(arg[idx])
   else
      s:resize(narg-idx+1)
      for i=idx,narg do
         if type(arg[idx]) == 'number' then
            s[i-idx+1] = arg[idx]
         else
            return false
         end
      end
   end
   return true
end]])
                return table.concat(txt, '\n')
             end,
   
   init = function(arg)
             if arg.default then
                error('LongArg cannot have a default value')
             end
          end,
   
   check = function(arg, idx)
              return string.format("islongargs(arg%d, %d, arg, narg)", arg.i, idx)
           end,
   
   read = function(arg, idx)
          end,
   
   carg = function(arg, idx)
             return string.format('arg%d', arg.i)
          end,

   creturn = function(arg, idx)
                return string.format('arg%d', arg.i)
             end,
   
   precall = function(arg)
             end,

   postcall = function(arg)
              end   
}

argtypes.charoption = {
   
   helpname = function(arg)
                 if arg.values then
                    return "(" .. table.concat(arg.values, '|') .. ")"
                 end
              end,

   declare = function(arg)
                return string.format('local arg%d', arg.i)
           end,

   init = function(arg)
             return string.format("arg%d = '%s'", arg.i, arg.default)
          end,
   
   check = function(arg, idx)
              local txt = {}
              local txtv = {}
              table.insert(txt, string.format('type(arg[%d]) == "string" and (', idx))
              for _,value in ipairs(arg.values) do
                 table.insert(txtv, string.format("arg[%d] == '%s'", idx, value))
              end
              table.insert(txt, table.concat(txtv, ' or '))
              table.insert(txt, ')')
              return table.concat(txt, '')
         end,

   read = function(arg, idx)
             return string.format('arg%d = arg[%d]', arg.i, idx)
          end,
   
   carg = function(arg, idx)
             return string.format('arg%d', arg.i)
          end,

   creturn = function(arg, idx)
             end,
   
   precall = function(arg)
             end,

   postcall = function(arg)
              end   
}

-- both interface & method support these new arguments
for k,v in pairs(argtypes) do
   interface.argtypes[k] = v
   method.argtypes[k] = v
end

interface.dispatchregistry = {}
function interface:wrap(name, ...)

   -- usual stuff
   wrap.CInterface.wrap(self, name, ...)

   -- dispatch function
   if not interface.dispatchregistry[name] then
      interface.dispatchregistry[name] = true

      interface:print(string.gsub([[
function torch.NAME(...)
   local arg = {...}
   local narg = #arg
   local flag, func
   flag, func = pcall(function(arg) return arg.torch.NAME end, arg[1])
   if not flag or not func then
      flag, func = pcall(function(arg) return arg.torch.NAME end, arg[1])
   end
   if not flag or not func then
      flag, func = pcall(function(arg) return torch[arg].torch.NAME end, arg[argn])
      if flag and func then
         table.remove(arg)
      end
   end
   if not flag or not func then
      flag, func = pcall(function() return torch.Tensor.torch.NAME end)
   end
   if not flag or not func then
      error('NAME is not implemented for the given tensor type')
   end
   return func(unpack(arg))
end
]], 'NAME', name))
   end
end

interface:print('--- WARNING: autogenerated file')
interface:print('')

local function wrap(...)
   local args = {...}

   -- interface
   interface:wrap(...)

   -- method: we override things possibly in method table field
   for _,x in ipairs(args) do
      if type(x) == 'table' then -- ok, now we have a list of args
         for _, arg in ipairs(x) do
            if arg.method then
               for k,v in pairs(arg.method) do
                  if v == 'nil' then -- special case, we erase the field
                     arg[k] = nil
                  else
                     arg[k] = v
                  end
               end
            end
         end
      end
   end
   method:wrap(unpack(args))
end

local reals = {ByteTensor='unsigned char',
               CharTensor='char',
               ShortTensor='short',
               IntTensor='int',
               LongTensor='long',
               FloatTensor='float',
               DoubleTensor='double'}

local accreals = {ByteTensor='long',
               CharTensor='long',
               ShortTensor='long',
               IntTensor='long',
               LongTensor='long',
               FloatTensor='double',
               DoubleTensor='double'}

for _,Tensor in ipairs({"ByteTensor", "CharTensor",
                        "ShortTensor", "IntTensor", "LongTensor",
                        "FloatTensor", "DoubleTensor"}) do

   local real = reals[Tensor]
   local accreal = accreals[Tensor]

   function interface.luaname2wrapname(self, name)
      return string.format('torch.%s.torch.%s', Tensor, name)
   end

   function method.luaname2wrapname(self, name)
      return string.format('torch.%s.%s', Tensor, name)
   end

   local function cname(name)
      return string.format('TH.TH%s_%s', Tensor, name)
   end

   local function lastdim(argn)
      return function(arg)
                return string.format("%s.__nDimension", arg.args[argn]:carg())
             end
   end

   interface:print(string.gsub(string.gsub(string.gsub([=[
ffi.cdef([[
void THTensor_fill(THTensor *r_, real value);
void THTensor_zero(THTensor *r_);

void THTensor_maskedFill(THTensor *tensor, THByteTensor *mask, real value);
void THTensor_maskedCopy(THTensor *tensor, THByteTensor *mask, THTensor* src);
void THTensor_maskedSelect(THTensor *tensor, THTensor* src, THByteTensor *mask);

accreal THTensor_dot(THTensor *t, THTensor *src);
  
real THTensor_minall(THTensor *t);
real THTensor_maxall(THTensor *t);
accreal THTensor_sumall(THTensor *t);

void THTensor_add(THTensor *r_, THTensor *t, real value);
void THTensor_mul(THTensor *r_, THTensor *t, real value);
void THTensor_div(THTensor *r_, THTensor *t, real value);

void THTensor_cadd(THTensor *r_, THTensor *t, real value, THTensor *src);  
void THTensor_cmul(THTensor *r_, THTensor *t, THTensor *src);
void THTensor_cdiv(THTensor *r_, THTensor *t, THTensor *src);

void THTensor_addcmul(THTensor *r_, THTensor *t, real value, THTensor *src1, THTensor *src2);
void THTensor_addcdiv(THTensor *r_, THTensor *t, real value, THTensor *src1, THTensor *src2);

void THTensor_addmv(THTensor *r_, real beta, THTensor *t, real alpha, THTensor *mat,  THTensor *vec);
void THTensor_addmm(THTensor *r_, real beta, THTensor *t, real alpha, THTensor *mat1, THTensor *mat2);
void THTensor_addr(THTensor *r_,  real beta, THTensor *t, real alpha, THTensor *vec1, THTensor *vec2);

long THTensor_numel(THTensor *t);
void THTensor_max(THTensor *values_, THLongTensor *indices_, THTensor *t, int dimension);
void THTensor_min(THTensor *values_, THLongTensor *indices_, THTensor *t, int dimension);
void THTensor_sum(THTensor *r_, THTensor *t, int dimension);
void THTensor_prod(THTensor *r_, THTensor *t, int dimension);
void THTensor_cumsum(THTensor *r_, THTensor *t, int dimension);
void THTensor_cumprod(THTensor *r_, THTensor *t, int dimension);
void THTensor_sign(THTensor *r_, THTensor *t);
accreal THTensor_trace(THTensor *t);
void THTensor_cross(THTensor *r_, THTensor *a, THTensor *b, int dimension);

void THTensor_zeros(THTensor *r_, THLongStorage *size);
void THTensor_ones(THTensor *r_, THLongStorage *size);
void THTensor_diag(THTensor *r_, THTensor *t, int k);
void THTensor_eye(THTensor *r_, long n, long m);
void THTensor_range(THTensor *r_, real xmin, real xmax, real step);
void THTensor_randperm(THTensor *r_, long n);

void THTensor_reshape(THTensor *r_, THTensor *t, THLongStorage *size);
void THTensor_sort(THTensor *rt_, THLongTensor *ri_, THTensor *t, int dimension, int descendingOrder);
void THTensor_tril(THTensor *r_, THTensor *t, long k);
void THTensor_triu(THTensor *r_, THTensor *t, long k);
void THTensor_cat(THTensor *r_, THTensor *ta, THTensor *tb, int dimension);

void THTensor_ltValue(THByteTensor *r_, THTensor* t, real value);
void THTensor_leValue(THByteTensor *r_, THTensor* t, real value);
void THTensor_gtValue(THByteTensor *r_, THTensor* t, real value);
void THTensor_geValue(THByteTensor *r_, THTensor* t, real value);
void THTensor_neValue(THByteTensor *r_, THTensor* t, real value);
void THTensor_eqValue(THByteTensor *r_, THTensor* t, real value);

void THTensor_ltTensor(THByteTensor *r_, THTensor *ta, THTensor *tb);
void THTensor_leTensor(THByteTensor *r_, THTensor *ta, THTensor *tb);
void THTensor_gtTensor(THByteTensor *r_, THTensor *ta, THTensor *tb);
void THTensor_geTensor(THByteTensor *r_, THTensor *ta, THTensor *tb);
void THTensor_neTensor(THByteTensor *r_, THTensor *ta, THTensor *tb);
void THTensor_eqTensor(THByteTensor *r_, THTensor *ta, THTensor *tb);
]])]=], 'THTensor', 'TH' .. Tensor), 'accreal', accreal), 'real', real))

   interface:print(string.format('torch.%s.torch = {}', Tensor))

   wrap("zero",
        cname("zero"),
        {{name=Tensor, returned=true}})
   
   wrap("fill",
        cname("fill"),
        {{name=Tensor, returned=true},
         {name='number'}})

   wrap("zeros",
        cname("zeros"),
        {{name=Tensor, default=true, returned=true, method={default='nil'}},
         {name="LongArg"}})

   wrap("ones",
        cname("ones"),
        {{name=Tensor, default=true, returned=true, method={default='nil'}},
         {name="LongArg"}})

   wrap("reshape",
        cname("reshape"),
        {{name=Tensor, default=true, returned=true},
         {name=Tensor},
         {name="LongArg"}})

   wrap("dot",
        cname("dot"),
        {{name=Tensor},
         {name=Tensor},
         {name='number', creturned=true}})
   
   wrap("add",
        cname("add"),
        {{name=Tensor, default=true, returned=true, method={default='nil'}},
         {name=Tensor, method={default=1}},
         {name='number'}},
        cname("cadd"),
        {{name=Tensor, default=true, returned=true, method={default='nil'}},
         {name=Tensor, method={default=1}},
         {name='number', default=1},
         {name=Tensor}})
   
   wrap("mul",
        cname("mul"),
        {{name=Tensor, default=true, returned=true, method={default='nil'}},
         {name=Tensor, method={default=1}},
         {name='number'}})

   wrap("div",
        cname("div"),
        {{name=Tensor, default=true, returned=true, method={default='nil'}},
         {name=Tensor, method={default=1}},
         {name='number'}})

   wrap("cmul",
        cname("cmul"),
        {{name=Tensor, default=true, returned=true, method={default='nil'}},
         {name=Tensor, method={default=1}},
         {name=Tensor}})

   wrap("cdiv",
        cname("cdiv"),
        {{name=Tensor, default=true, returned=true, method={default='nil'}},
         {name=Tensor, method={default=1}},
         {name=Tensor}})

   wrap("addcmul",
        cname("addcmul"),
        {{name=Tensor, default=true, returned=true, method={default='nil'}},
         {name=Tensor, method={default=1}},
         {name='number', default=1},
         {name=Tensor},
         {name=Tensor}})

   wrap("addcdiv",
        cname("addcdiv"),
        {{name=Tensor, default=true, returned=true, method={default='nil'}},
         {name=Tensor, method={default=1}},
         {name='number', default=1},
         {name=Tensor},
         {name=Tensor}})

   wrap("mv",
        cname("addmv"),
        {{name=Tensor, default=true, returned=true, method={default='nil'},
          init=function(arg)
                  return table.concat(
                     {
                        arg.__metatable.init(arg),
                        string.format("TH.TH%s_resize1d(%s, %s.__size[0])", Tensor, arg:carg(), arg.args[5]:carg())
                     }, '\n')
               end,
          precall=function(arg)
                     return table.concat(
                        {
                           string.format("TH.TH%s_zero(%s)", Tensor, arg:carg()),
                           arg.__metatable.precall(arg)
                        }, '\n')
                  end
       },
         {name='number', default=1, invisible=true},
         {name=Tensor, default=1, invisible=true},
         {name='number', default=1, invisible=true},
         {name=Tensor, dim=2},
         {name=Tensor, dim=1}}
     )

   wrap("mm",
        cname("addmm"),
        {{name=Tensor, default=true, returned=true, method={default='nil'},
          init=function(arg)
                  return table.concat(
                     {
                        arg.__metatable.init(arg),
                        string.format("TH.TH%s_resize2d(%s, %s.__size[0], %s.__size[1])", Tensor, arg:carg(), arg.args[5]:carg(), arg.args[6]:carg())
                     }, '\n')
               end,
          precall=function(arg)
                     return table.concat(
                        {
                           string.format("TH.TH%s_zero(%s)", Tensor, arg:carg()),
                           arg.__metatable.precall(arg)
                        }, '\n')
                  end
       },
         {name='number', default=1, invisible=true},
         {name=Tensor, default=1, invisible=true},
         {name='number', default=1, invisible=true},
         {name=Tensor, dim=2},
         {name=Tensor, dim=2}}
     )

   wrap("ger",
        cname("addr"),
        {{name=Tensor, default=true, returned=true, method={default='nil'},
          init=function(arg)
                  return table.concat(
                     {
                        arg.__metatable.init(arg),
                        string.format("TH.TH%s_resize2d(%s, %s.__size[0], %s.__size[0])", Tensor, arg:carg(), arg.args[5]:carg(), arg.args[6]:carg())
                     }, '\n')
               end,
          precall=function(arg)
                     return table.concat(
                        {
                           string.format("TH.TH%s_zero(%s)", Tensor, arg:carg()),
                           arg.__metatable.precall(arg)
                        }, '\n')
                  end
       },
        {name='number', default=1, invisible=true},
        {name=Tensor, default=1, invisible=true},
        {name='number', default=1, invisible=true},
        {name=Tensor, dim=1},
        {name=Tensor, dim=1}}
     )

   for _,f in ipairs({
                        {name="addmv", dim1=1, dim2=2, dim3=1},
                        {name="addmm", dim1=2, dim2=2, dim3=2},
                        {name="addr",  dim1=2, dim2=1, dim3=1},
                     }
                  ) do

      interface:wrap(f.name,
                     cname(f.name),
                     {{name=Tensor, default=true, returned=true},
                      {name='number', default=1},
                      {name=Tensor, dim=f.dim1},
                      {name='number', default=1},
                      {name=Tensor, dim=f.dim2},
                      {name=Tensor, dim=f.dim3}})

      -- there is an ambiguity here, hence the more complicated setup
      method:wrap(f.name,
                  cname(f.name),
                  {{name=Tensor, returned=true, dim=f.dim1},
                   {name='number', default=1, invisible=true},
                   {name=Tensor, default=1, dim=f.dim1},
                   {name='number', default=1},
                   {name=Tensor, dim=f.dim2},
                   {name=Tensor, dim=f.dim3}},
                  cname(f.name),
                  {{name=Tensor, returned=true, dim=f.dim1},
                   {name='number'},
                   {name=Tensor, default=1, dim=f.dim1},
                   {name='number'},
                   {name=Tensor, dim=f.dim2},
                   {name=Tensor, dim=f.dim3}})
   end

   wrap("numel",
        cname("numel"),
        {{name=Tensor},
         {name='number', creturned=true}})

   for _,name in ipairs({"prod", "cumsum", "cumprod"}) do
      wrap(name,
           cname(name),
           {{name=Tensor, default=true, returned=true},
            {name=Tensor},
            {name="index"}})
   end

   wrap("sum",
        cname("sumall"),
        {{name=Tensor},
         {name='number', creturned=true}},
        cname("sum"),
        {{name=Tensor, default=true, returned=true},
         {name=Tensor},
         {name="index"}})
   
   for _,name in ipairs({"min", "max"}) do
      wrap(name,
           cname(name .. "all"),
           {{name=Tensor},
            {name='number', creturned=true}},
           cname(name),
           {{name=Tensor, default=true, returned=true},
            {name="IndexTensor", default=true, returned=true},
            {name=Tensor},
            {name="index"}})
   end

   wrap("trace",
        cname("trace"),
        {{name=Tensor},
         {name='number', creturned=true}})
   
   wrap("cross",
        cname("cross"),
        {{name=Tensor, default=true, returned=true},
         {name=Tensor},
         {name=Tensor},
         {name="index", default=0}})
   
   wrap("diag",
        cname("diag"),
        {{name=Tensor, default=true, returned=true},
         {name=Tensor},
         {name='number', default=0}})
   
   wrap("eye",
        cname("eye"),
        {{name=Tensor, default=true, returned=true, method={default='nil'}},
         {name='number'},
         {name='number', default=0}})
   
   wrap("range",
        cname("range"),
        {{name=Tensor, default=true, returned=true, method={default='nil'}},
         {name='number'},
         {name='number'},
         {name='number', default=1}})

   wrap("randperm",
        cname("randperm"),
        {{name=Tensor, default=true, returned=true, method={default='nil'},
          postcall=function(arg)
                      return table.concat(
                         {
                            arg.__metatable.postcall(arg) or '',
                            string.format("TH.TH%s_add(%s, %s, 1)", Tensor, arg:carg(), arg:carg())
                         }, '\n')
                   end},
         {name='number'}})

   wrap("sort",
        cname("sort"),
        {{name=Tensor, default=true, returned=true},
         {name="IndexTensor", default=true, returned=true},
         {name=Tensor},
         {name="index", default=lastdim(3)},
         {name="boolean", default=0}})
   
   wrap("tril",
        cname("tril"),
        {{name=Tensor, default=true, returned=true},
         {name=Tensor},
         {name="number", default=0}})

   wrap("triu",
        cname("triu"),
        {{name=Tensor, default=true, returned=true},
         {name=Tensor},
         {name="number", default=0}})

   wrap("cat",
        cname("cat"),
        {{name=Tensor, default=true, returned=true},
         {name=Tensor},
         {name=Tensor},
         {name="index", default=lastdim(2)}})
   
   wrap('random',
        'THRandom_random2__',
        {{name='number'},
         {name='number'},
         {name='number', creturned=true}},
        'THRandom_random1__',
        {{name='number'},
         {name='number', creturned=true}},
        'THRandom_random',
        {{name='number', creturned=true}},
        cname("random2__"),
        {{name=Tensor, returned=true},
         {name='number'},
         {name='number'}},
        cname("random1__"),
        {{name=Tensor, returned=true},
         {name='number'}},
        cname("random"),
        {{name=Tensor, returned=true}})

   for _,f in ipairs({{name='geometric'},
                      {name='bernoulli', a=0.5}}) do
      
      wrap(f.name,
           string.format("THRandom_%s", f.name),
           {{name="number", default=f.a},
            {name="number", creturned=true}},
           cname(f.name),
           {{name=Tensor, returned=true},
            {name='number', default=f.a}})
   end

   wrap("squeeze",
        cname("squeeze"),
        {{name=Tensor, default=true, returned=true, postcall=function(arg)
                                                                local txt = {}
                                                                if arg.returned then
                                                                   table.insert(txt, string.format('if arg%d.__nDimension == 1 and arg%d.__size[0] == 1 then', arg.i, arg.i)) -- number
                                                                   table.insert(txt, string.format('arg%d = arg%d.__data[arg%d.__storageOffset]', arg.i, arg.i, arg.i))
                                                                   table.insert(txt, 'end')
                                                                end
                                                                return table.concat(txt, '\n')
                                                             end},
         {name=Tensor}},
        cname("squeeze1d"),
        {{name=Tensor, default=true, returned=true, postcall=function(arg)
                                                                local txt = {}
                                                                if arg.returned then
                                                                   table.insert(txt, string.format('if arg%d.__nDimension == 1 and arg%d.__size[0] == 1 then', arg.i, arg.i)) -- number
                                                                   table.insert(txt, string.format('arg%d = arg%d.__data[arg%d.__storageOffset]', arg.i, arg.i, arg.i))
                                                                   table.insert(txt, 'end')
                                                                end
                                                                return table.concat(txt, '\n')
                                                             end},
         {name=Tensor},
         {name="index"}})

   wrap("sign",
        cname("sign"),
        {{name=Tensor, default=true, returned=true, method={default='nil'}},
         {name=Tensor, method={default=1}}})

   wrap("conv2",
        cname("conv2Dmul"),
        {{name=Tensor, default=true, returned=true},
         {name='number', default=0, invisible=true},
         {name='number', default=1, invisible=true},
         {name=Tensor, dim=2},
         {name=Tensor, dim=2},
         {name='number', default=1, invisible=true},
         {name='number', default=1, invisible=true},
         {name='charoption', values={'V', 'F'}, default='V'},
         {name='charoption', default="C", invisible=true}},
        cname("conv2Dcmul"),
        {{name=Tensor, default=true, returned=true},
         {name='number', default=0, invisible=true},
         {name='number', default=1, invisible=true},
         {name=Tensor, dim=3},
         {name=Tensor, dim=3},
         {name='number', default=1, invisible=true},
         {name='number', default=1, invisible=true},
         {name='charoption', values={'V', 'F'}, default='V'},
         {name='charoption', default="C", invisible=true}},
        cname("conv2Dmv"),
        {{name=Tensor, default=true, returned=true},
         {name='number', default=0, invisible=true},
         {name='number', default=1, invisible=true},
         {name=Tensor, dim=3},
         {name=Tensor, dim=4},
         {name='number', default=1, invisible=true},
         {name='number', default=1, invisible=true},
         {name='charoption', values={'V', 'F'}, default='V'},
         {name='charoption', default="C", invisible=true}}
     )

   wrap("xcorr2",
        cname("conv2Dmul"),
        {{name=Tensor, default=true, returned=true},
         {name='number', default=0, invisible=true},
         {name='number', default=1, invisible=true},
         {name=Tensor, dim=2},
         {name=Tensor, dim=2},
         {name='number', default=1, invisible=true},
         {name='number', default=1, invisible=true},
         {name='charoption', values={'V', 'F'}, default='V'},
         {name='charoption', default="X", invisible=true}},
        cname("conv2Dcmul"),
        {{name=Tensor, default=true, returned=true},
         {name='number', default=0, invisible=true},
         {name='number', default=1, invisible=true},
         {name=Tensor, dim=3},
         {name=Tensor, dim=3},
         {name='number', default=1, invisible=true},
         {name='number', default=1, invisible=true},
         {name='charoption', values={'V', 'F'}, default='V'},
         {name='charoption', default="X", invisible=true}},
        cname("conv2Dmv"),
        {{name=Tensor, default=true, returned=true},
         {name='number', default=0, invisible=true},
         {name='number', default=1, invisible=true},
         {name=Tensor, dim=3},
         {name=Tensor, dim=4},
         {name='number', default=1, invisible=true},
         {name='number', default=1, invisible=true},
         {name='charoption', values={'V', 'F'}, default='V'},
         {name='charoption', default="X", invisible=true}}
     )

   wrap("conv3",
        cname("conv3Dmul"),
        {{name=Tensor, default=true, returned=true},
         {name='number', default=0, invisible=true},
         {name='number', default=1, invisible=true},
         {name=Tensor, dim=3},
         {name=Tensor, dim=3},
         {name='number', default=1, invisible=true},
         {name='number', default=1, invisible=true},
         {name='number', default=1, invisible=true},
         {name='charoption', values={'V', 'F'}, default='V'},
         {name='charoption', default="C", invisible=true}},
        cname("conv3Dcmul"),
        {{name=Tensor, default=true, returned=true},
         {name='number', default=0, invisible=true},
         {name='number', default=1, invisible=true},
         {name=Tensor, dim=4},
         {name=Tensor, dim=4},
         {name='number', default=1, invisible=true},
         {name='number', default=1, invisible=true},
         {name='number', default=1, invisible=true},
         {name='charoption', values={'V', 'F'}, default='V'},
         {name='charoption', default="C", invisible=true}},
        cname("conv3Dmv"),
        {{name=Tensor, default=true, returned=true},
         {name='number', default=0, invisible=true},
         {name='number', default=1, invisible=true},
         {name=Tensor, dim=4},
         {name=Tensor, dim=5},
         {name='number', default=1, invisible=true},
         {name='number', default=1, invisible=true},
         {name='number', default=1, invisible=true},
         {name='charoption', values={'V', 'F'}, default='V'},
         {name='charoption', default="C", invisible=true}}
     )

   wrap("xcorr3",
        cname("conv3Dmul"),
        {{name=Tensor, default=true, returned=true},
         {name='number', default=0, invisible=true},
         {name='number', default=1, invisible=true},
         {name=Tensor, dim=3},
         {name=Tensor, dim=3},
         {name='number', default=1, invisible=true},
         {name='number', default=1, invisible=true},
         {name='number', default=1, invisible=true},
         {name='charoption', values={'V', 'F'}, default='V'},
         {name='charoption', default="X", invisible=true}},
        cname("conv3Dcmul"),
        {{name=Tensor, default=true, returned=true},
         {name='number', default=0, invisible=true},
         {name='number', default=1, invisible=true},
         {name=Tensor, dim=4},
         {name=Tensor, dim=4},
         {name='number', default=1, invisible=true},
         {name='number', default=1, invisible=true},
         {name='number', default=1, invisible=true},
         {name='charoption', values={'V', 'F'}, default='V'},
         {name='charoption', default="X", invisible=true}},
        cname("conv3Dmv"),
        {{name=Tensor, default=true, returned=true},
         {name='number', default=0, invisible=true},
         {name='number', default=1, invisible=true},
         {name=Tensor, dim=4},
         {name=Tensor, dim=5},
         {name='number', default=1, invisible=true},
         {name='number', default=1, invisible=true},
         {name='number', default=1, invisible=true},
         {name='charoption', values={'V', 'F'}, default='V'},
         {name='charoption', default="X", invisible=true}}
     )

   for _,name in pairs({'lt','gt','le','ge','eq','ne'}) do
      wrap(name,
           cname(name .. 'Value'),
           {{name='ByteTensor',default=true, returned=true},
            {name=Tensor},
            {name='number'}},
           cname(name .. 'Tensor'),
           {{name='ByteTensor',default=true, returned=true},
            {name=Tensor},
            {name=Tensor}})
   end

   if Tensor == 'FloatTensor' or Tensor == 'DoubleTensor' then

      wrap("mean",
           cname("meanall"),
           {{name=Tensor},
            {name='number', creturned=true}},
           cname("mean"),
           {{name=Tensor, default=true, returned=true},
            {name=Tensor},
            {name="index"}})
      
      for _,name in ipairs({"var", "std"}) do
         wrap(name,
              cname(name .. "all"),
              {{name=Tensor},
               {name='number', creturned=true}},
              cname(name),
              {{name=Tensor, default=true, returned=true},
               {name=Tensor},
               {name="index"},
               {name="boolean", default=false}})
      end
      wrap("histc",
           cname("histc"),
           {{name=Tensor, default=true, returned=true},
            {name=Tensor},
            {name='number',default=100},
            {name="number",default=0},
            {name="number",default=0}})

      wrap("norm",
           cname("normall"),
           {{name=Tensor},
            {name='number', default=2},
            {name='number', creturned=true}},
           cname("norm"),
           {{name=Tensor, default=true, returned=true},
            {name=Tensor},
            {name='number'},
            {name="index"}})
      
      wrap("dist",
           cname("dist"),
           {{name=Tensor},
            {name=Tensor},
            {name='number', default=2},
            {name='number', creturned=true}})
      
      wrap("linspace",
           cname("linspace"),
           {{name=Tensor, default=true, returned=true, method={default='nil'}},
            {name='number'},
            {name='number'},
            {name='number', default=100}})

      wrap("logspace",
           cname("logspace"),
           {{name=Tensor, default=true, returned=true, method={default='nil'}},
            {name='number'},
            {name='number'},
            {name='number', default=100}})
      
      for _,name in ipairs({"log", "log1p", "exp",
                            "cos", "acos", "cosh",
                            "sin", "asin", "sinh",
                            "tan", "atan", "tanh",
                            "sqrt",
                            "ceil", "floor"}) do
                            --"abs"}) do

         wrap(name, 
              cname(name),
              {{name=Tensor, default=true, returned=true, method={default='nil'}},
               {name=Tensor, method={default=1}}},
              name,
              {{name='number'},
               {name='number', creturned=true}})
         
      end
         wrap("abs",
              cname("abs"),
              {{name=Tensor, default=true, returned=true, method={default='nil'}},
               {name=Tensor, method={default=1}}},
              "fabs",
              {{name='number'},
               {name='number', creturned=true}})

      wrap("atan2",
           cname("atan2"),
           {{name=Tensor, default=true, returned=true, method={default='nil'}},
            {name=Tensor, method={default=1}},
            {name=Tensor}},
           "atan2",
           {{name='number'},
            {name='number'},
            {name='number', creturned=true}}
            )

      wrap("pow",
           cname("pow"),
           {{name=Tensor, default=true, returned=true, method={default='nil'}},
            {name=Tensor, method={default=1}},
            {name='number'}},
           "pow",
           {{name='number'},
            {name='number'},
            {name='number', creturned=true}})

      wrap("rand",
           cname("rand"),
           {{name=Tensor, default=true, returned=true, method={default='nil'}},
            {name="LongArg"}})

      wrap("randn",
           cname("randn"),
           {{name=Tensor, default=true, returned=true, method={default='nil'}},
            {name="LongArg"}})
      
      for _,f in ipairs({{name='uniform', a=0, b=1},
                         {name='normal', a=0, b=1},
                         {name='cauchy', a=0, b=1},
                         {name='logNormal', a=1, b=2}}) do
         
         wrap(f.name,
              string.format("THRandom_%s", f.name),
              {{name="number", default=f.a},
               {name="number", default=f.b},
               {name="number", creturned=true}},
              cname(f.name),
              {{name=Tensor, returned=true},
               {name='number', default=f.a},
               {name='number', default=f.b}})
      end

      for _,f in ipairs({{name='exponential'}}) do
         
         wrap(f.name,
              string.format("THRandom_%s", f.name),
              {{name="number", default=f.a},
               {name="number", creturned=true}},
              cname(f.name),
              {{name=Tensor, returned=true},
               {name='number', default=f.a}})
      end
      
      for _,name in ipairs({"gesv","gels"}) do
         interface:wrap(name,
                        cname(name),
                        {{name=Tensor, returned=true},
                         {name=Tensor, returned=true},
                         {name=Tensor},
                         {name=Tensor}},
                        cname(name),
                        {{name=Tensor, default=true, returned=true, invisible=true},
                         {name=Tensor, default=true, returned=true, invisible=true},
                         {name=Tensor},
                         {name=Tensor}}
                     )
      end

      interface:wrap("symeig",
                     cname("syev"),
                     {{name=Tensor, returned=true},
                      {name=Tensor, returned=true},
                      {name=Tensor},
                      {name='charoption', values={'N', 'V'}, default='N'},
                      {name='charoption', values={'U', 'L'}, default='U'}},
                     cname("syev"),
                     {{name=Tensor, default=true, returned=true, invisible=true},
                      {name=Tensor, default=true, returned=true, invisible=true},
                      {name=Tensor},
                      {name='charoption', values={'N', 'V'}, default='N'},
                      {name='charoption', values={'U', 'L'}, default='U'}}
                  )
      interface:wrap("eig",
                     cname("geev"),
                     {{name=Tensor, returned=true},
                      {name=Tensor, returned=true},
                      {name=Tensor},
                      {name='charoption', values={'N', 'V'}, default='N'}},
                     cname("geev"),
                     {{name=Tensor, default=true, returned=true, invisible=true},
                      {name=Tensor, default=true, returned=true, invisible=true},
                      {name=Tensor},
                      {name='charoption', values={'N', 'V'}, default='N'}}
                  )

      interface:wrap("svd",
                     cname("gesvd"),
                     {{name=Tensor, returned=true},
                      {name=Tensor, returned=true},
                      {name=Tensor, returned=true},
                      {name=Tensor},
                      {name='charoption', values={'A', 'S'}, default='S'}},
                     cname("gesvd"),
                     {{name=Tensor, default=true, returned=true, invisible=true},
                      {name=Tensor, default=true, returned=true, invisible=true},
                      {name=Tensor, default=true, returned=true, invisible=true},
                      {name=Tensor},
                      {name='charoption', values={'A', 'S'}, default='S'}}
                  )
      interface:wrap("inverse",
                     cname("getri"),
                     {{name=Tensor, returned=true},
                      {name=Tensor}},
                     cname("getri"),
                     {{name=Tensor, default=true, returned=true, invisible=true},
                      {name=Tensor}}
                  )
      
   end

   interface:print(method:tostring())
   method:clearhistory()

end

if arg[1] then
   interface:tofile(arg[1])
else
   print(interface:tostring())
end
